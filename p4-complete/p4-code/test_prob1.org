#+TITLE: Problem 1 Bake Service Functions Tests
#+TESTY: PREFIX="prob1"
#+TESTY: USE_VALGRIND=1
# disable memory leak detection in forked children
#+TESTY: VALGRIND_PROG+=" --child-silent-after-fork=yes"


# CHANGELOG:
# 
# Tue Apr 16 05:06:30 PM EDT 2024 : Adjusted test 15 which had
# disagreement between IO redirect fields: input bit but output
# field + vice versa; fixed misspellings in a some output.

* slurp_file_efficient1
#+TESTY: program="./test_bake_funcs12 slurp_file_efficient1"
#+BEGIN_SRC sh
IF_TEST("slurp_file_efficient1") { 
    // Create a file then slurp it to show its contents are
    // corect. Single line file with text.
    system("echo 'Bake me a cake as quick as you can' > test-results/slurp1.txt");
    char *file_bytes = slurp_file_efficient("test-results/slurp1.txt");
    printf("file_bytes START\n%s\nfile_bytes STOP\n",file_bytes);
    free(file_bytes);
}
---OUTPUT---
file_bytes START
Bake me a cake as quick as you can

file_bytes STOP
#+END_SRC

* slurp_file_efficient2 
#+TESTY: program="./test_bake_funcs12 slurp_file_efficient2"
#+BEGIN_SRC sh
IF_TEST("slurp_file_efficient2") { 
    // Create a file then slurp it to show its contents are corect.
    // Larger file with number data.
    system("seq -w 100000000 1000000 200000000 > test-results/slurp2.txt");
    char *file_bytes = slurp_file_efficient("test-results/slurp1.txt");
    printf("file_bytes START\n%s\nfile_bytes STOP\n",file_bytes);
    free(file_bytes);
}
---OUTPUT---
file_bytes START
Bake me a cake as quick as you can

file_bytes STOP
#+END_SRC

* slurp_file_efficient_empty 
#+TESTY: program="./test_bake_funcs12 slurp_file_efficient_empty"
#+BEGIN_SRC sh
IF_TEST("slurp_file_efficient_empty") { 
    // Check for correct handling of empty files.
    system("touch test-results/slurp-empty.txt");
    char *file_bytes = slurp_file_efficient("test-results/slurp-empty.txt");
    printf("file_bytes START\n%s\nfile_bytes STOP\n",file_bytes);
    free(file_bytes);
}
---OUTPUT---
file_bytes START

file_bytes STOP
#+END_SRC

* slurp_file_efficient_fail 
#+TESTY: program="./test_bake_funcs12 slurp_file_efficient_fail"
#+BEGIN_SRC sh
IF_TEST("slurp_file_efficient_fail") { 
    // Check that slurping correctly returns NULL when a file can't be
    // opened. The function should use perror() to print the message
    // "Couldn't open file" which will append a reason for it.
    system("rm -f test-results/slurp-not-there.txt");
    char *file_bytes = slurp_file_efficient("test-results/slurp-not-there.txt");
    printf("file_bytes START\n%s\nfile_bytes STOP\n",file_bytes);
    // free(file_bytes);   // should be NULL so no need to free
}
---OUTPUT---
Couldn't open file: No such file or directory
file_bytes START
(null)
file_bytes STOP
#+END_SRC

* bake_target_rule1 
#+TESTY: program="./test_bake_funcs12 bake_target_rule1"
#+BEGIN_SRC sh
IF_TEST("bake_target_rule1") { 
    // checks that the rule associated with an existing target is
    // found in a small bake
    rule_t rules[8] = {
      { .target      = "target0",
        .deps        = {"dep0A","dep0B","dep0C"},
        .cmd_count   = 2,
        .cmds        = {
          { .tokens = {"a","b","c"} },
          { .tokens = {"d","e"} },
        }
      },
      { .target      = "target1",
        .deps        = {"dep1A","dep1B"},
        .cmd_count   = 3,
        .cmds        = {
          { .tokens = {"a","b","c"} },
          { .tokens = {"d","e"} },
          { .tokens = {"f","g","h"} },
        }
      },            
      { .target      = "target2",
        .deps        = {"dep2A","dep2B","dep2C","dep2D"},
        .cmd_count   = 1,
        .cmds        = {
          { .tokens = {"a","b","c"} },
        }
      },            
    };
    bake_t bake = {
      .filename      = "<none>",
      .rule_capacity = 8,
      .rule_count    = 3,
      .rules         = rules,
      .string_table  = NULL
    };
    rule_t *rule;

    printf("FIRST LOOKUP\n");
    rule = bake_target_rule(&bake, "target1");
    if(rule == NULL){
      printf("rule not found\n");
    }
    else{
      bake_show_rule(rule,0);
    }

    printf("SECOND LOOKUP\n");
    rule = bake_target_rule(&bake, "target2");
    if(rule == NULL){
      printf("rule not found\n");
    }
    else{
      bake_show_rule(rule,0);
    }
}
---OUTPUT---
FIRST LOOKUP
rule_t {
  target = target1
  deps[ 0] = 'dep1A'
  deps[ 1] = 'dep1B'
  deps[ 2] = (null)
  rule_flags = 0x00 [ -- -- -- ]
  cmd_count = 3
  cmds[ 0] =
    cmd_t {
      tokens[ 0] = 'a'
      tokens[ 1] = 'b'
      tokens[ 2] = 'c'
      tokens[ 3] = (null)
      input_redirect = '(null)'
      output_redirect = '(null)'
      line_number = 0
      cmd_flags = 0x00 [ -- -- -- ]
    }
  cmds[ 1] =
    cmd_t {
      tokens[ 0] = 'd'
      tokens[ 1] = 'e'
      tokens[ 2] = (null)
      input_redirect = '(null)'
      output_redirect = '(null)'
      line_number = 0
      cmd_flags = 0x00 [ -- -- -- ]
    }
  cmds[ 2] =
    cmd_t {
      tokens[ 0] = 'f'
      tokens[ 1] = 'g'
      tokens[ 2] = 'h'
      tokens[ 3] = (null)
      input_redirect = '(null)'
      output_redirect = '(null)'
      line_number = 0
      cmd_flags = 0x00 [ -- -- -- ]
    }
}
SECOND LOOKUP
rule_t {
  target = target2
  deps[ 0] = 'dep2A'
  deps[ 1] = 'dep2B'
  deps[ 2] = 'dep2C'
  deps[ 3] = 'dep2D'
  deps[ 4] = (null)
  rule_flags = 0x00 [ -- -- -- ]
  cmd_count = 1
  cmds[ 0] =
    cmd_t {
      tokens[ 0] = 'a'
      tokens[ 1] = 'b'
      tokens[ 2] = 'c'
      tokens[ 3] = (null)
      input_redirect = '(null)'
      output_redirect = '(null)'
      line_number = 0
      cmd_flags = 0x00 [ -- -- -- ]
    }
}
#+END_SRC

* bake_target_rule2 
#+TESTY: program="./test_bake_funcs12 bake_target_rule2"
#+BEGIN_SRC sh
IF_TEST("bake_target_rule2") { 
    // Checks if a variety of targets are present/absent in a 
    // Bakefile loaded from the data/ directory
    printf("BAKEFILE CONTENTS\n");
    system("cat data/Bakefile3");
    bake_t *bake = bake_create_from_file("data/Bakefile3"); 
    char *targname;  
    printf("\nCHECKING TARGETS\n");
    targname = "all";
    printf("CHECK %12s : %s\n",targname,
           bake_target_rule(bake,targname)!=NULL?"FOUND":"NULL");
    targname = "hello.o";
    printf("CHECK %12s : %s\n",targname,
           bake_target_rule(bake,targname)!=NULL?"FOUND":"NULL");
    targname = "clean";
    printf("CHECK %12s : %s\n",targname,
           bake_target_rule(bake,targname)!=NULL?"FOUND":"NULL");
    targname = "demo";
    printf("CHECK %12s : %s\n",targname,
           bake_target_rule(bake,targname)!=NULL?"FOUND":"NULL");
    targname = "bye.o";
    printf("CHECK %12s : %s\n",targname,
           bake_target_rule(bake,targname)!=NULL?"FOUND":"NULL");
    targname = "nada.c";
    printf("CHECK %12s : %s\n",targname,
           bake_target_rule(bake,targname)!=NULL?"FOUND":"NULL");
    targname = "missing";
    printf("CHECK %12s : %s\n",targname,
           bake_target_rule(bake,targname)!=NULL?"FOUND":"NULL");
    targname = "nowhere.txt";
    printf("CHECK %12s : %s\n",targname,
           bake_target_rule(bake,targname)!=NULL?"FOUND":"NULL");
    bake_free(bake);
}
---OUTPUT---
BAKEFILE CONTENTS
# this is a leading comment

# this target uses the program that is built
# and runs it printing messages around it
demo : hello bye
	@ echo Running programs
	./hello
	./bye
	@ echo Done running programs

all : hello bye

# this is program 1 / 2
hello : hello.o
	gcc -o hello hello.o

hello.o : hello.c
	gcc -c hello.c

# this is program 2 / 2
bye : bye.o
	gcc -o bye bye.o

bye.o : bye.c
	gcc -c bye.c

# this target removes built files
clean :
	rm -f hello.o bye.o hello bye

CHECKING TARGETS
CHECK          all : FOUND
CHECK      hello.o : FOUND
CHECK        clean : FOUND
CHECK         demo : FOUND
CHECK        bye.o : FOUND
CHECK       nada.c : NULL
CHECK      missing : NULL
CHECK  nowhere.txt : NULL
#+END_SRC

* bake_target_rule_missing 
#+TESTY: program="./test_bake_funcs12 bake_target_rule_missing"
#+BEGIN_SRC sh
IF_TEST("bake_target_rule_missing") { 
    // checks that NULL is returned when a target is missing from all
    // rules
    rule_t rules[8] = {
      { .target      = "target0",
        .deps        = {"dep0A","dep0B","dep0C"},
        .cmd_count   = 2,
        .cmds        = {
          { .tokens = {"a","b","c"} },
          { .tokens = {"d","e"} },
        }
      },
      { .target      = "target1",
        .deps        = {"dep1A","dep1B"},
        .cmd_count   = 3,
        .cmds        = {
          { .tokens = {"a","b","c"} },
          { .tokens = {"d","e"} },
          { .tokens = {"f","g","h"} },
        }
      },            
      { .target      = "target2",
        .deps        = {"dep2A","dep2B","dep2C","dep2D"},
        .cmd_count   = 1,
        .cmds        = {
          { .tokens = {"a","b","c"} },
        }
      },            
    };
    bake_t bake = {
      .filename      = "<none>",
      .rule_capacity = 8,
      .rule_count    = 3,
      .rules         = rules,
      .string_table  = NULL
    };
    rule_t *rule = bake_target_rule(&bake, "targetX");
    if(rule == NULL){
      printf("rule not found\n");
    }
    else{
      bake_show_rule(rule,0);
    }
}
---OUTPUT---
rule not found
#+END_SRC

* bake_add_empty_rule1 
#+TESTY: program="./test_bake_funcs12 bake_add_empty_rule1"
#+BEGIN_SRC sh
IF_TEST("bake_add_empty_rule1") { 
    // Loads a Bakefile with a single rule, adds an empty rule and
    // modifies to check data lands in the right place
    printf("BAKEFILE CONTENTS\n");
    system("cat data/Bakefile1");
    bake_t *bake = bake_create_from_file("data/Bakefile1"); // 1 rule
    rule_t *new_rule = bake_add_empty_rule(bake);
    new_rule->target = "new_target";
    printf("\nAFTER add\n");
    bake_show_bake(bake,0);
    bake_free(bake);
}
---OUTPUT---
BAKEFILE CONTENTS
# this is a comment

hello : hello.c
      gcc -o hello hello.c

AFTER add
bake_t {
  filename = data/Bakefile1
  rule_capacity = 4
  rule_count = 2
  rules[ 0] =
    rule_t {
      target = hello
      deps[ 0] = 'hello.c'
      deps[ 1] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 1
      cmds[ 0] =
        cmd_t {
          tokens[ 0] = 'gcc'
          tokens[ 1] = '-o'
          tokens[ 2] = 'hello'
          tokens[ 3] = 'hello.c'
          tokens[ 4] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 4
          cmd_flags = 0x00 [ -- -- -- ]
        }
    }
  rules[ 1] =
    rule_t {
      target = new_target
      deps[ 0] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 0
    }
}
#+END_SRC

* bake_add_empty_rule2 
#+TESTY: program="./test_bake_funcs12 bake_add_empty_rule2"
#+BEGIN_SRC sh
IF_TEST("bake_add_empty_rule2") { 
    // Loads a Bakefile with a single rule, adds an several empty
    // rules with modifications. This should trigger expansion of the
    // rules array accommodate the new rules.
    printf("BAKEFILE CONTENTS\n");
    system("cat data/Bakefile2");
    bake_t *bake = bake_create_from_file("data/Bakefile2"); // 3 rules
    rule_t *new_rule;
    new_rule = bake_add_empty_rule(bake); // 4 rules
    new_rule->target = "target4";
    new_rule = bake_add_empty_rule(bake); // 5 rules
    new_rule->target = "target5";         // capacity to 8
    new_rule = bake_add_empty_rule(bake); // 6 rules
    new_rule->target = "target6";
    printf("\n====3 ADDS: CAPACITY 8====\n");
    bake_show_bake(bake,0);

    new_rule = bake_add_empty_rule(bake); // 7 rules
    new_rule->target = "target7";
    new_rule = bake_add_empty_rule(bake); // 8 rules
    new_rule->target = "target8";
    new_rule = bake_add_empty_rule(bake); // 9 rules
    new_rule->target = "target9";         // capacity to 16
    printf("\n====6 ADDS CAPACITY 16====\n");
    bake_show_bake(bake,0);

    bake_free(bake);
}
---OUTPUT---
BAKEFILE CONTENTS
# this is a leading comment

# this target uses the program that is built
# and runs it printing messages around it
demo : hello hello.c
	@ echo Running hello
	./hello
	@ echo Done running hello

# this is the principle program
hello : hello.c
	gcc -o hello hello.c


# this target removes built files
clean :
	rm -f hello

====3 ADDS: CAPACITY 8====
bake_t {
  filename = data/Bakefile2
  rule_capacity = 8
  rule_count = 6
  rules[ 0] =
    rule_t {
      target = demo
      deps[ 0] = 'hello'
      deps[ 1] = 'hello.c'
      deps[ 2] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 3
      cmds[ 0] =
        cmd_t {
          tokens[ 0] = '@'
          tokens[ 1] = 'echo'
          tokens[ 2] = 'Running'
          tokens[ 3] = 'hello'
          tokens[ 4] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 6
          cmd_flags = 0x00 [ -- -- -- ]
        }
      cmds[ 1] =
        cmd_t {
          tokens[ 0] = './hello'
          tokens[ 1] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 7
          cmd_flags = 0x00 [ -- -- -- ]
        }
      cmds[ 2] =
        cmd_t {
          tokens[ 0] = '@'
          tokens[ 1] = 'echo'
          tokens[ 2] = 'Done'
          tokens[ 3] = 'running'
          tokens[ 4] = 'hello'
          tokens[ 5] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 8
          cmd_flags = 0x00 [ -- -- -- ]
        }
    }
  rules[ 1] =
    rule_t {
      target = hello
      deps[ 0] = 'hello.c'
      deps[ 1] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 1
      cmds[ 0] =
        cmd_t {
          tokens[ 0] = 'gcc'
          tokens[ 1] = '-o'
          tokens[ 2] = 'hello'
          tokens[ 3] = 'hello.c'
          tokens[ 4] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 12
          cmd_flags = 0x00 [ -- -- -- ]
        }
    }
  rules[ 2] =
    rule_t {
      target = clean
      deps[ 0] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 1
      cmds[ 0] =
        cmd_t {
          tokens[ 0] = 'rm'
          tokens[ 1] = '-f'
          tokens[ 2] = 'hello'
          tokens[ 3] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 17
          cmd_flags = 0x00 [ -- -- -- ]
        }
    }
  rules[ 3] =
    rule_t {
      target = target4
      deps[ 0] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 0
    }
  rules[ 4] =
    rule_t {
      target = target5
      deps[ 0] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 0
    }
  rules[ 5] =
    rule_t {
      target = target6
      deps[ 0] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 0
    }
}

====6 ADDS CAPACITY 16====
bake_t {
  filename = data/Bakefile2
  rule_capacity = 16
  rule_count = 9
  rules[ 0] =
    rule_t {
      target = demo
      deps[ 0] = 'hello'
      deps[ 1] = 'hello.c'
      deps[ 2] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 3
      cmds[ 0] =
        cmd_t {
          tokens[ 0] = '@'
          tokens[ 1] = 'echo'
          tokens[ 2] = 'Running'
          tokens[ 3] = 'hello'
          tokens[ 4] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 6
          cmd_flags = 0x00 [ -- -- -- ]
        }
      cmds[ 1] =
        cmd_t {
          tokens[ 0] = './hello'
          tokens[ 1] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 7
          cmd_flags = 0x00 [ -- -- -- ]
        }
      cmds[ 2] =
        cmd_t {
          tokens[ 0] = '@'
          tokens[ 1] = 'echo'
          tokens[ 2] = 'Done'
          tokens[ 3] = 'running'
          tokens[ 4] = 'hello'
          tokens[ 5] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 8
          cmd_flags = 0x00 [ -- -- -- ]
        }
    }
  rules[ 1] =
    rule_t {
      target = hello
      deps[ 0] = 'hello.c'
      deps[ 1] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 1
      cmds[ 0] =
        cmd_t {
          tokens[ 0] = 'gcc'
          tokens[ 1] = '-o'
          tokens[ 2] = 'hello'
          tokens[ 3] = 'hello.c'
          tokens[ 4] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 12
          cmd_flags = 0x00 [ -- -- -- ]
        }
    }
  rules[ 2] =
    rule_t {
      target = clean
      deps[ 0] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 1
      cmds[ 0] =
        cmd_t {
          tokens[ 0] = 'rm'
          tokens[ 1] = '-f'
          tokens[ 2] = 'hello'
          tokens[ 3] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 17
          cmd_flags = 0x00 [ -- -- -- ]
        }
    }
  rules[ 3] =
    rule_t {
      target = target4
      deps[ 0] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 0
    }
  rules[ 4] =
    rule_t {
      target = target5
      deps[ 0] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 0
    }
  rules[ 5] =
    rule_t {
      target = target6
      deps[ 0] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 0
    }
  rules[ 6] =
    rule_t {
      target = target7
      deps[ 0] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 0
    }
  rules[ 7] =
    rule_t {
      target = target8
      deps[ 0] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 0
    }
  rules[ 8] =
    rule_t {
      target = target9
      deps[ 0] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 0
    }
}
#+END_SRC

* bake_add_implicit_rules1 
#+TESTY: program="./test_bake_funcs12 bake_add_implicit_rules1"
#+BEGIN_SRC sh
IF_TEST("bake_add_implicit_rules1") { 
    // Loads a Bakefile with a single explicit rule and checks that
    // bake_add_implicit_rules() adds in implict rules for its
    // dependency
    printf("ORIGINAL FILE\n");
    system("cat data/BakeImplicit1");
    bake_t *bake = bake_create_from_file("data/BakeImplicit1");
    bake_add_implicit_rules(bake);
    printf("\nAFTER bake_add_implicit_rules()\n");
    bake_show_bake(bake,0);
    bake_free(bake);
}
---OUTPUT---
ORIGINAL FILE
# this is a comment

hello : hello.c
      gcc -o hello hello.c

AFTER bake_add_implicit_rules()
bake_t {
  filename = data/BakeImplicit1
  rule_capacity = 4
  rule_count = 2
  rules[ 0] =
    rule_t {
      target = hello
      deps[ 0] = 'hello.c'
      deps[ 1] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 1
      cmds[ 0] =
        cmd_t {
          tokens[ 0] = 'gcc'
          tokens[ 1] = '-o'
          tokens[ 2] = 'hello'
          tokens[ 3] = 'hello.c'
          tokens[ 4] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 4
          cmd_flags = 0x00 [ -- -- -- ]
        }
    }
  rules[ 1] =
    rule_t {
      target = hello.c
      deps[ 0] = (null)
      rule_flags = 0x02 [ -- IM -- ]
      cmd_count = 0
    }
}
#+END_SRC

* bake_add_implicit_rules2 
#+TESTY: program="./test_bake_funcs12 bake_add_implicit_rules2"
#+BEGIN_SRC sh
IF_TEST("bake_add_implicit_rules2") { 
    // Loads a Bakefile with several rules with dependencies which
    // need to be have implicit rules created for them
    printf("ORIGINAL FILE\n");
    system("cat data/BakeImplicit2");
    bake_t *bake = bake_create_from_file("data/BakeImplicit2");
    bake_add_implicit_rules(bake);
    printf("\nAFTER bake_add_implicit_rules()\n");
    bake_show_bake(bake,0);
    bake_free(bake);
}
---OUTPUT---
ORIGINAL FILE
# used to tests implicit rule creation
program1 : sourceA.c sourceB.c
	command1
	command2

program2 : sourceA.c sourceC.c
	command1

program3 : sourceB.c sourceD.c sourceA.c
	command1
	command2
	command3

AFTER bake_add_implicit_rules()
bake_t {
  filename = data/BakeImplicit2
  rule_capacity = 8
  rule_count = 7
  rules[ 0] =
    rule_t {
      target = program1
      deps[ 0] = 'sourceA.c'
      deps[ 1] = 'sourceB.c'
      deps[ 2] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 2
      cmds[ 0] =
        cmd_t {
          tokens[ 0] = 'command1'
          tokens[ 1] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 3
          cmd_flags = 0x00 [ -- -- -- ]
        }
      cmds[ 1] =
        cmd_t {
          tokens[ 0] = 'command2'
          tokens[ 1] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 4
          cmd_flags = 0x00 [ -- -- -- ]
        }
    }
  rules[ 1] =
    rule_t {
      target = program2
      deps[ 0] = 'sourceA.c'
      deps[ 1] = 'sourceC.c'
      deps[ 2] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 1
      cmds[ 0] =
        cmd_t {
          tokens[ 0] = 'command1'
          tokens[ 1] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 7
          cmd_flags = 0x00 [ -- -- -- ]
        }
    }
  rules[ 2] =
    rule_t {
      target = program3
      deps[ 0] = 'sourceB.c'
      deps[ 1] = 'sourceD.c'
      deps[ 2] = 'sourceA.c'
      deps[ 3] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 3
      cmds[ 0] =
        cmd_t {
          tokens[ 0] = 'command1'
          tokens[ 1] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 10
          cmd_flags = 0x00 [ -- -- -- ]
        }
      cmds[ 1] =
        cmd_t {
          tokens[ 0] = 'command2'
          tokens[ 1] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 11
          cmd_flags = 0x00 [ -- -- -- ]
        }
      cmds[ 2] =
        cmd_t {
          tokens[ 0] = 'command3'
          tokens[ 1] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 12
          cmd_flags = 0x00 [ -- -- -- ]
        }
    }
  rules[ 3] =
    rule_t {
      target = sourceA.c
      deps[ 0] = (null)
      rule_flags = 0x02 [ -- IM -- ]
      cmd_count = 0
    }
  rules[ 4] =
    rule_t {
      target = sourceB.c
      deps[ 0] = (null)
      rule_flags = 0x02 [ -- IM -- ]
      cmd_count = 0
    }
  rules[ 5] =
    rule_t {
      target = sourceC.c
      deps[ 0] = (null)
      rule_flags = 0x02 [ -- IM -- ]
      cmd_count = 0
    }
  rules[ 6] =
    rule_t {
      target = sourceD.c
      deps[ 0] = (null)
      rule_flags = 0x02 [ -- IM -- ]
      cmd_count = 0
    }
}
#+END_SRC

* bake_add_implicit_rules3 
#+TESTY: program="./test_bake_funcs12 bake_add_implicit_rules3"
#+BEGIN_SRC sh
IF_TEST("bake_add_implicit_rules3") { 
    // Loads a larger bakefile wiht the need to create several
    // implicit rules.
    printf("ORIGINAL FILE\n");
    system("cat data/BakeImplicit3");
    bake_t *bake = bake_create_from_file("data/BakeImplicit3");
    bake_add_implicit_rules(bake);
    printf("\nAFTER bake_add_implicit_rules()\n");
    bake_show_bake(bake,0);
    bake_free(bake);
}
---OUTPUT---
ORIGINAL FILE
# used to tests implicit rule creation 
# deeper implicit targets
program1 : sourceA.c sourceB.c
	command1
	command2

# sourceA.c is not implicit but
# inputA.dat is
sourceA.c : inputA.dat
	command3

# check that no implicit rules are
# creatd when there are no deps
program2 : 
	command4
	command5

program3 : sourceC.c sourceD.c
	command6
	command7

# sourceC. is NOT implicit
sourceC.c :
	command8

# sourceD.c nests several deep
sourceD.c : inputD.dat
	command9

# calcD.txt is the only implicit target
inputD.dat : calcD.txt
	command10


AFTER bake_add_implicit_rules()
bake_t {
  filename = data/BakeImplicit3
  rule_capacity = 16
  rule_count = 10
  rules[ 0] =
    rule_t {
      target = program1
      deps[ 0] = 'sourceA.c'
      deps[ 1] = 'sourceB.c'
      deps[ 2] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 2
      cmds[ 0] =
        cmd_t {
          tokens[ 0] = 'command1'
          tokens[ 1] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 4
          cmd_flags = 0x00 [ -- -- -- ]
        }
      cmds[ 1] =
        cmd_t {
          tokens[ 0] = 'command2'
          tokens[ 1] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 5
          cmd_flags = 0x00 [ -- -- -- ]
        }
    }
  rules[ 1] =
    rule_t {
      target = sourceA.c
      deps[ 0] = 'inputA.dat'
      deps[ 1] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 1
      cmds[ 0] =
        cmd_t {
          tokens[ 0] = 'command3'
          tokens[ 1] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 10
          cmd_flags = 0x00 [ -- -- -- ]
        }
    }
  rules[ 2] =
    rule_t {
      target = program2
      deps[ 0] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 2
      cmds[ 0] =
        cmd_t {
          tokens[ 0] = 'command4'
          tokens[ 1] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 15
          cmd_flags = 0x00 [ -- -- -- ]
        }
      cmds[ 1] =
        cmd_t {
          tokens[ 0] = 'command5'
          tokens[ 1] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 16
          cmd_flags = 0x00 [ -- -- -- ]
        }
    }
  rules[ 3] =
    rule_t {
      target = program3
      deps[ 0] = 'sourceC.c'
      deps[ 1] = 'sourceD.c'
      deps[ 2] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 2
      cmds[ 0] =
        cmd_t {
          tokens[ 0] = 'command6'
          tokens[ 1] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 19
          cmd_flags = 0x00 [ -- -- -- ]
        }
      cmds[ 1] =
        cmd_t {
          tokens[ 0] = 'command7'
          tokens[ 1] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 20
          cmd_flags = 0x00 [ -- -- -- ]
        }
    }
  rules[ 4] =
    rule_t {
      target = sourceC.c
      deps[ 0] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 1
      cmds[ 0] =
        cmd_t {
          tokens[ 0] = 'command8'
          tokens[ 1] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 24
          cmd_flags = 0x00 [ -- -- -- ]
        }
    }
  rules[ 5] =
    rule_t {
      target = sourceD.c
      deps[ 0] = 'inputD.dat'
      deps[ 1] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 1
      cmds[ 0] =
        cmd_t {
          tokens[ 0] = 'command9'
          tokens[ 1] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 28
          cmd_flags = 0x00 [ -- -- -- ]
        }
    }
  rules[ 6] =
    rule_t {
      target = inputD.dat
      deps[ 0] = 'calcD.txt'
      deps[ 1] = (null)
      rule_flags = 0x00 [ -- -- -- ]
      cmd_count = 1
      cmds[ 0] =
        cmd_t {
          tokens[ 0] = 'command10'
          tokens[ 1] = (null)
          input_redirect = '(null)'
          output_redirect = '(null)'
          line_number = 32
          cmd_flags = 0x00 [ -- -- -- ]
        }
    }
  rules[ 7] =
    rule_t {
      target = sourceB.c
      deps[ 0] = (null)
      rule_flags = 0x02 [ -- IM -- ]
      cmd_count = 0
    }
  rules[ 8] =
    rule_t {
      target = inputA.dat
      deps[ 0] = (null)
      rule_flags = 0x02 [ -- IM -- ]
      cmd_count = 0
    }
  rules[ 9] =
    rule_t {
      target = calcD.txt
      deps[ 0] = (null)
      rule_flags = 0x02 [ -- IM -- ]
      cmd_count = 0
    }
}
#+END_SRC

* bake_print_cmd_simple 
#+TESTY: program="./test_bake_funcs12 bake_print_cmd_simple"
#+BEGIN_SRC sh
IF_TEST("bake_print_cmd_simple") { 
    // Checks output of a very simple command without any special
    // flags set.
    cmd_t cmd = {
      .tokens = {"gcc","-o","myprog","-g","prog_main.c"},
      .input_redirect  = NULL,
      .output_redirect = NULL,
      .line_number = 32,
      .cmd_flags = 0
    };
    bake_print_cmd(&cmd);
}
---OUTPUT---
gcc -o myprog -g prog_main.c 
#+END_SRC

* bake_print_cmd_silence 
#+TESTY: program="./test_bake_funcs12 bake_print_cmd_silence"
#+BEGIN_SRC sh
IF_TEST("bake_print_cmd_silence") { 
    // Checks that when the SILENCE_BIT is set, no output is printed.
    cmd_t cmd = {
      .tokens = {"echo","Alas poor Yorick, I knew him, Horatio."},
      .input_redirect  = NULL,
      .output_redirect = NULL,
      .line_number = 13,
      .cmd_flags = CMD_SILENCE_BIT,
    };
    bake_print_cmd(&cmd);
}
---OUTPUT---
IF_TEST("bake_print_cmd_silence") { 
    // Checks that when the SILENCE_BIT is set, no output is printed.
    cmd_t cmd = {
      .tokens = {"echo","Alas poor Yorick, I knew him, Horatio."},
      .input_redirect  = NULL,
      .output_redirect = "hamlet.txt",
      .line_number = 8,
      .cmd_flags = CMD_SILENCE_BIT|CMD_OUTREDI_BIT,
    };
    bake_print_cmd(&cmd);
}
---OUTPUT---
#+END_SRC

* bake_print_cmd_io_redir 
#+TESTY: program="./test_bake_funcs12 bake_print_cmd_io_redir"
#+BEGIN_SRC sh
IF_TEST("bake_print_cmd_io_redir") { 
    // Checks output redirection detected and printed correctly when
    // displaying commands
    cmd_t cmd = {
      .tokens = {"seq","10","5","50"},
      .input_redirect  = NULL,
      .output_redirect = "nums.txt",
      .line_number = 31,
      .cmd_flags = CMD_OUTREDI_BIT,
    };
    bake_print_cmd(&cmd);
}
---OUTPUT---
seq 10 5 50 > nums.txt 
IF_TEST("bake_print_cmd_io_redir") { 
    // Checks input redirection detected and printed correctly when
    // displaying commands
    cmd_t cmd = {
      .tokens = {"wc","-l"},
      .input_redirect  = "essay.txt",
      .output_redirect = NULL,
      .line_number = 145,
      .cmd_flags = CMD_INPREDI_BIT,
    };
    bake_print_cmd(&cmd);
}
---OUTPUT---
wc -l < essay.txt 
IF_TEST("bake_print_cmd_io_redir") { 
    // Checks input/output redirection detected and printed correctly
    // when displaying commands
    cmd_t cmd = {
      .tokens = {"tr","a-z","A-Z"},
      .input_redirect  = "mixed.txt",
      .output_redirect = "upper.txt",
      .line_number = 259,
      .cmd_flags = CMD_OUTREDI_BIT | CMD_INPREDI_BIT
    };
    bake_print_cmd(&cmd);
}
---OUTPUT---
tr a-z A-Z < mixed.txt > upper.txt 
#+END_SRC

